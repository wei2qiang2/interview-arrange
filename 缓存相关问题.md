[TOC]

#### 常见题目

##### 缓存穿透，缓存击穿和缓存雪崩的定义及解决方案

1. **穿透**：在缓存中和数据库中都没有这类数据，但是这样的请求并发量特别高，增加数据库的压力，导致数据库机器崩掉（缓存和数据库都查不到此类数据）

   **解决方案**：给请求增加身份校验，字段校验（如`id`不能为负数等）；在缓存中没查询到的数据，数据库也没有的数据同样放入到缓存中，`value`设置为`null`

2. **雪崩**：缓存中大量的数据（`key`不相同的）过期，而此时涌来大量的查询需求，导致数据库服务器压力增大宕机。（缓存大量失效，去数据库查询，数据库宕机）

   **解决方案**：随机设置过期时间，避免大量`key`同一时间过期，热点数据设置永不过期。

3. **击穿**：在缓存中某个某个`key`过期了，而此时正好大量的并发请求查询此`key`,所以大量请求都涌入数据库，数据库宕机。(与穿透不同的是只是一个`key`)

   **解决方案**：热点数据永不过期；根据`key`加互斥锁

##### 缓存如何使用的

##### `redis`的工作原理

​	<img src="images\01_redis单线程模型.png" alt="01_redis单线程模型" style="zoom:50%;" />

​	`redis`的单线程的`nio`模型

##### 聊聊`redis`的线程模型

​	文件事件处理器：单线程的。`IO`多路复用监听

##### 为啥`redis`是单线程的，性能比多线程的`memcached`高，为什么单线程效率也这么高？

​	`redis`拥有的数据结构和操作比`memcached`都多

​	非阻塞`IO`+纯内存操作

​	`IO`多路复用程序单线程只做监听功能，监听所有的客户端`socket`,监听到客户端的命令之后，不作处理，先是压入队列（**非阻塞多路复用`IO`**），事件处理器（**连接应答处理器**，**命令请求处理器**，**命令回复处理器**）再从队列拿请求处理（**纯内存操作**），处理完一个请求后再从队列里面拿。

​	`redis`是单线程，`memcached`是多线程，`redis`存储小数据性能高，`memcached`存储大数据的性能高。

​	`memcache`是没有原生的集群模式的，`redis从3.0`版本后开始支持`redis-cluster`模式

##### `redis`有哪些数据类型？分别适合哪些场景下使用？

​	`string`：简单的`key-value`存储

​	`set`：没有顺序，但是可以去重。可以进行全局去重，交集，并集，差集计算。

​	`hash`：类似于map的结构，主要用来存放对象，后续操作的时候可以仅仅修改某个字段的值，别的不用变

​	`list`：一个列表，有顺序，可重复（微博的粉丝列表：key（博主），`value：[zhangsan,lisi,wangwu]`）,常用的命令：`lrange`，可以进行分页查询，指定从那个元素开始，读多少个元素。

​	`sortedset`：排序的（根据分数排序：`zadd board 80 zhangsan` `zadd board 75 lisi`  `zadd board  70 wangwu`会自动排序,获取前三名：`zervrange board 0 3`,查看`zhangsan`排名第几：`zrank board zhangsan`），去重。

##### `redis`的过期策略有哪些？手写一个`LRU`

**往`redis`写的数据怎么没了**

​	内存不足，`redis`清理掉了不常使用的数据。

**设置了过期时间，到期后数据没了，怎么还站着内存**

​	到期后并没有删除掉，除非去查询一次才会删除。

**`redis`是怎么将过期的数据的过期策略:定期删除+惰性删除**

​	**定期删除**：每隔`100ms`就随机抽取一些设置了过期时间的`key`进行检查是否过期，如果过期就删除。并不是删除所有过期的数据，这样会造成性能问题。（假设设置了10万个`key`都设置了过期时间，每次都去检查所有的key是否过期的话那么会消耗相当多的`cpu`）

​	**惰性删除**：当你在访问某个`key`的时候（有可能这个key已经过期了但是还没有删除），`redis`会检查你的`key`是否过期，如果过期了会删除，不会返回。

内存里面堆积了大量的数据：走`redis`的自行淘汰机制

**淘汰机制分类**：

​	`noevcation`:	内存不足的时候写入报错，一般不用。

​	`allkeys-lru`:	移除最近最少使用的，最常使用。

​	`allkeys-random`:	随机找些`key`删除，不合适。

​	`valotile-lru`:	在设置了过期时间中移除最近最少使用的。

​	`valotile-random`:	在设置了过期时间中的随机删除。

​	`valotile-ttl`:	在设置了过期时间中删除最先过期的。

##### 讲一下`redis`的持久化机制

​	单独`fork()`一个子进程，将当前父进程的数据库复制到子进程的内存中，然后又由子进程写入到临时文件中，持久化的过程结束后，再用这个临时文件替换上次的快照文件，然后子进程退出，内存释放。

​	`RDB`:	默认的持久化策略，是按照一定的周期将内存的数据以快照的形式保存成硬盘上的二进制文件。

​	`AOF`:	`redis`会将每次收到的写命令追加到一个保存命令的文件中，当重启`redis`的时候，通过读这个命令文件重新执行所有的写操作。

​	**总结：当两种方式都开启的时候，会采用`AOF`来恢复缓存中的数据。** 

​	总结：当两种方式都开启的时候，会采用`AOF`来恢复缓存中的数据。

#### `redis`主从复制

##### `redis`的主从复制原理

​	`slave`第一次连上`master`的时候，`master`会将`rdb`文件传送给slave，与此同时，master将之后的命令缓存在内存之中，slave接收到了`rdb`文件，先持久化到磁盘上，再从磁盘读取到内存中并开始同步数据（这个过程称之为full `resynchrognization`）。然后`master`将内存中缓存的命令发送给`slave`，`slave`继续同步。

​	当在同步`rdb`文件的过程中断开之后，再次连接上时会进行断点续传。

`slave node`: 用来读的，增加读的并发量

``master node``: `master`节点必须使用持久化机制（开启`AOF`或者`RDB`），

##### 主从复制的断点续传

​	从`redis2.8`开始，就支持主从复制的断点续传，如果主从复制中，网络连接断掉了，那么可以接着上次复制的地方，继续复制下去，而不是从头开始复制以分。`master`会在内存中中创建一个`backlog`，`master`和`slave`都会保存一个`replica offset`和一个`master id`，`offset`就是保存在`backlog`中的。如果`master`和`slave`的网络连接断掉了，`slave`会让`master`从上次的`replica offset`开始继续复制，但是如果没有找到对应的`offset`，那么就会执行一次`resynchronization`

##### 无磁盘化复制

​	`master`在内存中直接创建`rdb`，然后发送给`slave`，不会存在自己的本地磁盘了

##### 过期key处理

​	`slave`不会过期`key`，只会等待`master`的过期`key`。如果`master`过期了一个`key`，或者通过`LRU`淘汰了一个`key`，那么就会模拟一条`del`命令发送给`slave`

##### 主从复制的完整流程

1. `slave node`启动，加载配置文件的`master`的`host`和`id`
2. `slave node`本身有一个定时任务，每秒检查是否有新的`master node`要连接和复制，如果有，就和该`master node`建立`socket`连接
3. `slave node`向已连接的`master`发出ping命令
4. `master`开始进行口令验证，如果master配置了`requirepass`，那么`slave node`必须向`master`发送`masterauth`的口令进行认证
5. `master node`第一次执行全量复制，将全部数据发送给`slave node`
6. `master node`之后异步将写命令发送给`slave node`

##### 数据同步的核心关键机制

1. **`master` 和 `slave`都会维护一个`offset`**

   `master`和`slave`都各自维护一个`offset`,都会不断地进行累加，`slave`也会每秒上报自己的`offset`。通过`master`和`slave`的`offset`就可以知道两边的数据是否一致。

2. **`master run id`**

   `slave`无法通过`host+ip`识别一个`master`，因为当一个`master`重启之后这个是不会改变的，但是`run id`会改变，如果`run id` 不同就需要做全量复制了。可以通过`info server`查看`master run id`。如果需要不更改`run id`重启`redis`，可以使用`redis-cli debug reload`命令

3. **`backlog`**

   `master node`有一个`backlog`文件，当做全量复制的时候断开了之后在连接上用来做增量复制的，每当`master`向`slave`复制数据的时候都会在`backlog`中也复制一份。

4. **`psync`**

   从节点使用`psync`从`master node`进行复制，`psync runid offset`
   `master node`会根据自身的情况返回响应信息，可能是`FULLRESYNC runid offset`触发全量复制，可能是`CONTINUE`触发增量复制

##### 全量复制的详细过程

1. `master`执行`bgsave`，在本地生成一份`rdb`文件
2. 通过网络将`rdb`发送给`slave`，发送的时间默认超过`60s`时发送失败，具体超时时间可调整`repl-time`参数
3. `master`在生成`rdb`文件的时候会将新的命令写进缓存中，等到`rdb`文件复制完成之后，`master`会向`slave`发送缓存中的命令
4. `client-output-buffer-limit` `slave` `256MB` `64MB` `60`，如果在复制期间，内存缓冲区持续消耗超过`64MB`，或者一次性超过`256MB`，那么停止复制，复制失败
5. `slave`再接收到`rdb`文件之后，清空旧数据并将`rdb`加载到内存中，加载的同时基于旧数据版本对外提供服务
6. 如果`slave`开启了`AOF`，那么`slave`接收到`rdb`之后会立即执行`BGREWRITE`,重写`AOF`
7. `rdb`文件的生成，`rdb`文件的网络传输，`slave`旧数据的清理，`slave of rewrite aof`这些过程都需要消耗大量时间，一个`4G~6G`的`RDB`文件大约会传输1分半到2分钟。

##### 增量复制

1. `master node`在和`slave node`发生全量复制的过程中，他们之间的网络断开了，触发增量复制
2. 再次连接上后，`slave node`向`master node`发送`psync`命令，并带有`offset`参数
3. `master node`接收到`slave node`的命令以及`offset`参数之后，就在`backlog`中找到`offset`的位置继续发送`backlog`中的数据

##### 心跳机制

​	主从节点之间会相互发送心跳信息，`master`默认`10s`像`slave`发送`heartbeat`，`slave`默认`1s`向`master`发送`heartbeat`

##### 异步复制

​	`master node`每次接收到写命令之后都会现在内部写入数据，然后再异步发送给`slave node`

#### `redis`的哨兵机制

##### 哨兵的介绍

1. 集群监控：负责监控集群中的`master`和`slave`是否都正常工作
2. 消息通知：如果某个`redis`实例发生故障，那么他会发送报警信息通知管理员
3. 故障转移：如果`master node`挂掉了，会自动转移到`slave`上
4. 配置中心：如果故障转移发生了，会自动通知客户端新的`master`地址

##### 哨兵的核心知识

​	至少需要三个哨兵实例，并且哨兵+主从架构的部署不能保证数据零丢失，只能保证高可用

##### 为什么哨兵只有两个无法工作

##### 经典的3节点哨兵集群

​                                                                                                                                                                                                                                                             