[TOC]



##### 缓存如何使用的

##### `redis`的工作原理

​	<img src="images\01_redis单线程模型.png" alt="01_redis单线程模型" style="zoom:50%;" />

​	`redis`的单线程的`nio`模型

##### 聊聊`redis`的线程模型

​	文件事件处理器：单线程的。`IO`多路复用监听

##### 为啥`redis`是单线程的，性能比多线程的`memcached`高，为什么单线程效率也这么高？

​	`redis`拥有的数据结构和操作比`memcached`都多

​	非阻塞`IO`+纯内存操作

​	`IO`多路复用程序单线程只做监听功能，监听所有的客户端`socket`,监听到客户端的命令之后，不作处理，先是压入队列（**非阻塞多路复用`IO`**），事件处理器（**连接应答处理器**，**命令请求处理器**，**命令回复处理器**）再从队列拿请求处理（**纯内存操作**），处理完一个请求后再从队列里面拿。

​	`redis`是单线程，`memcached`是多线程，`redis`存储小数据性能高，`memcached`存储大数据的性能高。

​	`memcache`是没有原生的集群模式的，`redis从3.0`版本后开始支持`redis-cluster`模式

##### `redis`有哪些数据类型？分别适合哪些场景下使用？

​	`string`：简单的`key-value`存储

​	`set`：没有顺序，但是可以去重。可以进行全局去重，交集，并集，差集计算。

​	`hash`：类似于map的结构，主要用来存放对象，后续操作的时候可以仅仅修改某个字段的值，别的不用变

​	`list`：一个列表，有顺序，可重复（微博的粉丝列表：key（博主），`value：[zhangsan,lisi,wangwu]`）,常用的命令：`lrange`，可以进行分页查询，指定从那个元素开始，读多少个元素。

​	`sortedset`：排序的（根据分数排序：`zadd board 80 zhangsan` `zadd board 75 lisi`  `zadd board  70 wangwu`会自动排序,获取前三名：`zervrange board 0 3`,查看`zhangsan`排名第几：`zrank board zhangsan`），去重。

##### `redis`的过期策略有哪些？手写一个`LRU`

**往`redis`写的数据怎么没了**

​	内存不足，`redis`清理掉了不常使用的数据。

**设置了过期时间，到期后数据没了，怎么还站着内存**

​	到期后并没有删除掉，除非去查询一次才会删除。

**`redis`是怎么将过期的数据的过期策略:定期删除+惰性删除**

​	**定期删除**：每隔`100ms`就随机抽取一些设置了过期时间的`key`进行检查是否过期，如果过期就删除。并不是删除所有过期的数据，这样会造成性能问题。（假设设置了10万个`key`都设置了过期时间，每次都去检查所有的key是否过期的话那么会消耗相当多的`cpu`）

​	**惰性删除**：当你在访问某个`key`的时候（有可能这个key已经过期了但是还没有删除），`redis`会检查你的`key`是否过期，如果过期了会删除，不会返回。

内存里面堆积了大量的数据：走`redis`的自行淘汰机制

淘汰机制分类：

​	`noevcation`:	内存不足的时候写入报错，一般不用。

​	`allkeys-lru`:	移除最近最少使用的，最常使用。

​	`allkeys-random`:	随机找些`key`删除，不合适。

​	`valotile-lru`:	在设置了过期时间中移除最近最少使用的。

​	`valotile-random`:	在设置了过期时间中的随机删除。

​	`valotile-ttl`:	在设置了过期时间中删除最先过期的。

##### `redis` 如何保证高可用

`redis`单机的`QPS`在一万到几万不等，具体多少视自己的机子的配置而决定。

`redis`的`QPS`要超过十万，那应该怎么做呢，读的QPS比写的QPS大得多？

一般的做法就是读写分离(一主多从，`master`负责写，`slave`负责读)。大量的请求都是读的。当读的`QPS`增大之后直接增加`slave`节点就可以了(水平扩容)。

##### `redis`主从架构` ->` 读写分离架构 `->` 可支持水平扩展的读高并发架构

![](images\redis主从实现读写分离支撑10万+的高并发.png)

redis是以异步的方式从master把数据复制到slave节点的。