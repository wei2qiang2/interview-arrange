##### 缓存如何使用的

##### `redis`的工作原理

​	<img src="images\01_redis单线程模型.png" alt="01_redis单线程模型" style="zoom:50%;" />

​	`redis`的单线程的`nio`模型

##### 聊聊`redis`的线程模型

​	文件事件处理器：单线程的。`IO`多路复用监听

##### 为啥`redis`是单线程的，性能比多线程的`memcached`高，为什么单线程效率也这么高？

​	`redis`拥有的数据结构和操作比`memcached`都多

​	非阻塞`IO`+纯内存操作

​	`IO`多路复用程序单线程只做监听功能，监听所有的客户端`socket`,监听到客户端的命令之后，不作处理，先是压入队列（**非阻塞多路复用`IO`**），事件处理器（**连接应答处理器**，**命令请求处理器**，**命令回复处理器**）再从队列拿请求处理（**纯内存操作**），处理完一个请求后再从队列里面拿。

​	`redis`是单线程，`memcached`是多线程，`redis`存储小数据性能高，`memcached`存储大数据的性能高。

​	`memcache`是没有原生的集群模式的，`redis从3.0`版本后开始支持`redis-cluster`模式

##### `redis`有哪些数据类型？分别适合哪些场景下使用？

​	`string`：简单的`key-value`存储

​	`set`：没有顺序，但是可以去重。可以进行全局去重，交集，并集，差集计算。

​	`hash`：类似于map的结构，主要用来存放对象，后续操作的时候可以仅仅修改某个字段的值，别的不用变

​	`list`：一个列表，有顺序，可重复（微博的粉丝列表：key（博主），`value：[zhangsan,lisi,wangwu]`）,常用的命令：`lrange`，可以进行分页查询，指定从那个元素开始，读多少个元素。

​	`sortedset`：排序的（根据分数排序：`zadd board 80 zhangsan` `zadd board 75 lisi`  `zadd board  70 wangwu`会自动排序,获取前三名：`zervrange board 0 3`,查看`zhangsan`排名第几：`zrank board zhangsan`），去重。

##### `redis`的过期策略有哪些？手写一个`LRU`

**往`redis`写的数据怎么没了**

​	内存不足，`redis`清理掉了不常使用的数据。

**设置了过期时间，到期后数据没了，怎么还站着内存**

​	到期后并没有删除掉，除非去查询一次才会删除。

**`redis`是怎么将过期的数据的过期策略:定期删除+惰性删除**

​	**定期删除**：每隔`100ms`就随机抽取一些设置了过期时间的`key`进行检查是否过期，如果过期就删除。并不是删除所有过期的数据，这样会造成性能问题。（假设设置了10万个`key`都设置了过期时间，每次都去检查所有的key是否过期的话那么会消耗相当多的`cpu`）

​	**惰性删除**：当你在访问某个`key`的时候（有可能这个key已经过期了但是还没有删除），`redis`会检查你的`key`是否过期，如果过期了会删除，不会返回。

内存里面堆积了大量的数据：走`redis`的自行淘汰机制

淘汰机制分类：

​	`noevcation`:	内存不足的时候写入报错，一般不用。

​	`allkeys-lru`:	移除最近最少使用的，最常使用。

​	`allkeys-random`:	随机找些`key`删除，不合适。

​	`valotile-lru`:	在设置了过期时间中移除最近最少使用的。

​	`valotile-random`:	在设置了过期时间中的随机删除。

​	`valotile-ttl`:	在设置了过期时间中删除最先过期的。

##### 讲一下`redis`的持久化机制

​	单独`fork()`一个子进程，将当前父进程的数据库复制到子进程的内存中，然后又由子进程写入到临时文件中，持久化的过程结束后，再用这个临时文件替换上次的快照文件，然后子进程退出，内存释放。

​	`RDB`:	默认的持久化策略，是按照一定的周期将内存的数据以快照的形式保存成硬盘上的二进制文件。

​	`AOF`:	`redis`会将每次收到的写命令追加到一个保存命令的文件中，当重启`redis`的时候，通过读这个命令文件重新执行所有的写操作。

​	总结：当两种方式都开启的时候，会采用`AOF`来恢复缓存中的数据。